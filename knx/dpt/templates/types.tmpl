// Copyright 2017 Ole Kr√ºger.
// Licensed under the MIT license which can be found in the LICENSE file.

package dpt

import (
	"fmt"
)

// A DatapointValue is a value of a datapoint.
type DatapointValue interface {
	Pack() []byte
	Unpack(data []byte) error
	Unit() string
}

{{ range $i,$desc := . -}}
{{- /* Define some useful variables */ -}}
{{- $dpt_apprev := (replace $desc.Id "." "") -}}
{{- $dpt_type := (print "DPT_" $dpt_apprev) -}}
{{- $dpt_unit := $desc.Unit -}}
{{- /* Escape unit for printing if necessary */ -}}
{{- if eq $desc.Unit "%" -}}
{{-   $dpt_unit = (print "%" $desc.Unit) -}}
{{- end -}}
{{- /* Format specific variable declaration */ -}}
{{- $format_type       := "" -}}
{{- $format_scale      := false -}}
{{- $format_range_low  := 0 -}}
{{- $format_range_high := 1 -}}
{{- $format_print      := "%v" -}}
{{- /* Set format specific constants */ -}}
{{- if eq $desc.Format "B1" -}}
{{-   $format_type       = "bool" -}}
{{-   $format_print      = "%s" -}}
{{- else if eq $desc.Format "U8" -}}
{{-   $format_type       = "uint8" -}}
{{-   $format_scale      = true -}}
{{-   $format_range_low  = 0 -}}
{{-   $format_range_high = 255 -}}
{{-   $format_print      = "%.2f" -}}
{{- else if eq $desc.Format "F16" -}}
{{-   $format_type       = "float32" -}}
{{-   $format_print      = "%.2f" -}}
{{- end -}}

// DPT {{$desc.Id}} ({{$desc.Name}})
type {{$dpt_type}} {{$desc.Type}}

// DatapointValue interface functions
func (d {{$dpt_type}}) Pack() []byte {
{{- if not (isset $desc.Range) }}
	return pack{{$desc.Format}}({{$format_type}}(d))
{{- else }}
	value := d

	// Clip the value to a valid range
{{-   if (isset $desc.Range.Low) }}
	if value < {{$desc.Range.Low}} {
		value = {{$desc.Range.Low}}
	}
{{-   end }}
{{-   if $desc.Range.High }}
	if value > {{$desc.Range.High}} {
		value = {{$desc.Range.High}}
	}
{{-   end }}
{{    if and $format_scale (not (iseqf $desc.Range.High $format_range_high)) }}
	// Scale the value to the target range
{{-     if $desc.Range.High }}
	value /= {{$desc.Range.High}}
{{-     end }}
	value *= {{$format_range_high}}
{{    end }}
	return pack{{$desc.Format}}({{$format_type}}(value))
{{- end }}
}

func (d *{{$dpt_type}}) Unpack(data []byte) error {
{{- if not (isset $desc.Range) }}
	return unpack{{$desc.Format}}(data, (*{{$format_type}})(d))
{{- else }}
	var buf {{$format_type}}

	err := unpack{{$desc.Format}}(data, &buf)
	if err == nil {
		value := {{$dpt_type}}(buf)
{{    if and $format_scale (not (iseqf $desc.Range.High $format_range_high)) }}
		// Scale the value
{{-     if (isset $desc.Range.High) }}
		value *= {{$desc.Range.High}}
{{-     end }}
		value /= {{$format_range_high}}
{{    end }}
		// Check the value for valid range
{{-   if $desc.Range.Low }}
		if value < {{$desc.Range.Low}} {
			return fmt.Errorf("value \"{{$format_print}}\" outside range [{{$desc.Range.Low}}, {{$desc.Range.High}}]", value)
		}
{{-   end }}
{{-   if $desc.Range.High }}
		if value > {{$desc.Range.High}} {
			return fmt.Errorf("value \"{{$format_print}}\" outside range [{{$desc.Range.Low}}, {{$desc.Range.High}}]", value)
		}
{{-   end }}

		*d = value
	}

	return nil
{{- end }}
}

// Returns string representation of unit or nil if value has no unit
func (d {{$dpt_type}}) Unit() string {
{{- if $desc.Unit }}
	return "{{$desc.Unit}}"
{{- else }}
	return ""
{{- end }}
}

// Generates string representation of value
func (d {{$dpt_type}}) String() string {
{{-   if $desc.ValueMap }}
	value_map := map[{{$desc.Type}}]string{
{{-     $first := true -}}
{{-     range $key,$value := .ValueMap }}
{{-       if not $first -}}, {{ end -}}
		{{- $key }}: "{{ $value }}"
{{-       $first = false -}}
{{-     end -}}
	}

	return value_map[{{- $desc.Type -}}(d)]
{{-   else if not $desc.Unit }}
	return fmt.Sprintf("{{$format_print}}", $desc.Type(d))
{{-   else }}
	return fmt.Sprintf("{{$format_print}}{{$dpt_unit}}", {{$desc.Type}}(d))
{{-   end }}
}

{{  end -}}
